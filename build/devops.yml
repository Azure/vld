name: $(BuildID)_$(BuildDefinitionName)_$(SourceBranchName)_$(Date:yyyyMMdd)$(Rev:.r)
resources:
- repo: self
  clean: true

parameters:
- name: architectures
  type: object
  default:
    - name: 'x64'
      cmakeArch: 'x64'
      vcvarsArg: 'amd64'
      platform: 'x64'
      pool: 'Azure-MessagingStore-WinBuildPoolVS2022_0'
    - name: 'x86'
      cmakeArch: 'Win32'
      vcvarsArg: 'amd64_x86'
      platform: 'Win32'
      pool: 'Azure-MessagingStore-WinBuildPoolVS2022_0'
    - name: 'arm64'
      cmakeArch: 'ARM64'
      # arm64_arm64 = native ARM64 host producing ARM64 binaries
      # This requires escaping from WoW64 context (see below)
      vcvarsArg: 'arm64_arm64'
      platform: 'ARM64'
      pool: 'Azure-MessagingStore-WinBuildPoolARM'
- name: configurations
  type: object
  default:
    - 'Debug'
    - 'RelWithDebInfo'

jobs:
- ${{ each arch in parameters.architectures }}:
  - ${{ each config in parameters.configurations }}:
    - job: Build_Windows_${{ arch.name }}_${{ config }}
      displayName: 'Build Windows ${{ arch.name }} ${{ config }}'
      pool:
        name: ${{ arch.pool }}
        demands:
        - Cmd
        - msbuild
        - visualstudio
        - Build
      steps:

      # =============================================================================
      # ARM64 NATIVE BUILD ENVIRONMENT SETUP
      # =============================================================================
      # The Azure DevOps agent on ARM64 machines runs as a 32-bit x86 process under
      # WoW64 emulation. This causes vcvarsall.bat to reject 'arm64_arm64' and forces
      # MSBuild to use the x86-hosted cross-compiler (HostX86/arm64) instead of the
      # native ARM64 compiler (Hostarm64/arm64).
      #
      # Solution: Use %SystemRoot%\SysNative to escape WoW64 and run vcvarsall in
      # native ARM64 context. SysNative is a virtual folder that redirects to the
      # real System32 (native binaries) when accessed from a WoW64 process.
      #
      # This task:
      # 1. Escapes WoW64 via SysNative\cmd.exe
      # 2. Runs vcvarsall.bat arm64_arm64 to set up native ARM64 build environment
      # 3. Exports the environment variables to subsequent pipeline tasks
      # 4. Sets ARM64_MSBUILD variable pointing to native ARM64 MSBuild
      # =============================================================================
      - ${{ if eq(arch.name, 'arm64') }}:
        - task: PowerShell@2
          displayName: 'Setup ARM64 native build environment (escape WoW64)'
          inputs:
            targetType: 'inline'
            script: |
              $vcvarsall = "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Auxiliary\Build\vcvarsall.bat"
              $nativeCmd = "$env:SystemRoot\SysNative\cmd.exe"
              
              Write-Host "Escaping WoW64 via SysNative to run vcvarsall arm64_arm64..."
              $envOutput = & $nativeCmd /c "`"$vcvarsall`" arm64_arm64 >nul 2>&1 && set" 2>&1
              
              foreach ($line in $envOutput) {
                if ($line -match '^([^=]+)=(.*)$') {
                  $name = $matches[1]
                  $value = $matches[2]
                  # Export environment variables that vcvarsall sets
                  if ($name -match '^(PATH|INCLUDE|LIB|LIBPATH|VCToolsInstallDir|VCToolsVersion|VisualStudioVersion|VSCMD_ARG_HOST_ARCH|VSCMD_ARG_TGT_ARCH|WindowsSdkDir|WindowsSDKVersion|VCINSTALLDIR|DevEnvDir)$') {
                    Write-Host "##vso[task.setvariable variable=$name]$value"
                  }
                }
              }
              
              # Export the native ARM64 MSBuild path for VSBuild task
              $arm64Msbuild = "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\MSBuild\Current\Bin\arm64\msbuild.exe"
              Write-Host "##vso[task.setvariable variable=ARM64_MSBUILD]$arm64Msbuild"
              Write-Host "ARM64 native environment configured. MSBuild: $arm64Msbuild"

      # x64/x86: Setup VC++ environment via vcvarsall (runs natively, no escape needed)
      - ${{ if ne(arch.vcvarsArg, 'arm64_arm64') }}:
        - task: BatchScript@1
          displayName: 'Setup VC++ Environment (${{ arch.vcvarsArg }})'
          inputs:
            filename: '"C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Auxiliary\Build\vcvarsall.bat"'
            arguments: '${{ arch.vcvarsArg }}'
            modifyEnvironment: true

      - task: CMake@1
        displayName: 'CMake .. -DVLD_USE_MFC=OFF -A ${{ arch.cmakeArch }}'
        inputs:
          workingDirectory: 'build_${{ arch.name }}'
          cmakeArgs: '.. -DVLD_USE_MFC=OFF -A ${{ arch.cmakeArch }}'

      # ARM64: Use VSBuild with explicit ARM64 MSBuild path
      - ${{ if eq(arch.name, 'arm64') }}:
        - task: VSBuild@1
          displayName: 'Build solution ${{ config }}'
          inputs:
            solution: 'build_${{ arch.name }}\*.sln'
            msbuildLocation: '$(ARM64_MSBUILD)'
            platform: ${{ arch.platform }}
            configuration: ${{ config }}
            msbuildArgs: '/t:restore /t:build'
            maximumCpuCount: true

      # x64/x86: Use VSBuild normally
      - ${{ if ne(arch.name, 'arm64') }}:
        - task: VSBuild@1
          displayName: 'Build solution ${{ config }}'
          inputs:
            solution: 'build_${{ arch.name }}\*.sln'
            platform: ${{ arch.platform }}
            configuration: ${{ config }}
            msbuildArgs: '/t:restore /t:build'
            maximumCpuCount: true

      - task: CmdLine@2
        displayName: 'Run ctest ${{ config }}'
        inputs:
          script: 'ctest -C "${{ config }}" --output-on-failure'
          workingDirectory: 'build_${{ arch.name }}'
